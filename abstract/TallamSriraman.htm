<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body>
<div align="justify">
Faults are common-place and inevitable in complex applications. Hence, automated
techniques are necessary to analyze failed executions and debug the application to locate the fault. For locating faults in programs, dynamic slices have been shown to be very effective in reducing the effort of debugging. The user needs to inspect only a small subset of program statements to get to the root cause of the fault. The dynamic slice connects the various executed instructions through dependences and the root cause of the fault is found by inspecting the instructions in the dynamic slice starting from the point where the execution failed. While prior work has primarily focussed on single-threaded programs, this dissertation shows how dynamic slicing can be used for fault location in multithreaded programs. This dissertation also shows that dynamic slices can be used to track down faults due to data races in multithreaded programs by incorporating additional data dependences that arise in the presence of many threads. It shows how the dynamic slices of multithreaded programs are represented and how they are traversed for fault location. Case studies presented show that, using dynamic slices, less than 5 program statements had to
inspected to discover the root cause of the bug. In order to construct the dynamic slices, dependence traces (control and data) are collected and processed. However, program runs generate traces in the order of Gigabytes in a few seconds. Hence, for multithreaded program runs that are longrunning, the process of collecting and storing these traces poses a significant challenge.
This dissertation proposes two techniques to overcome this challenge. First, a new trace representation is proposed to store the generated control and data dependence traces compactly on disk. Second, schemes that can reduce the size of the generated traces by exploiting certain program characteristics and tracing only the region of execution that is relevant to the fault is proposed. Experiments indicate that the compact representation for trace compression can help reduce the space required to store the generated traces by upto an order of magnitude and the execution reduction technique that traces only the relevant portions of the execution can reduce the size of the generated traces by 2 to 5 orders of magnitude. For applications that are critical and for which down time is highly detrimental, techniques for surviving software failures and letting the execution continue are desired. This dissertation proposes one such technique to recover applications from a class of faults that are caused by the execution environment. The technique survives a fault by rolling back the execution to an appropriate program point and re-executing the code region under a modified environment. The environment modification (patch) that prevents the fault is noted to be re-applied if necessary to avoid the fault from recurring again in the future. This technique has been successfully used to avoid faults in a variety of applications caused due to thread scheduling, heap overflow, and
malformed user requests. Case studies indicate that, for most environment bugs, the point in the execution where the environment modification is necessary can be clearly pin-pointed by using the proposed system and the fault can be avoided in the first attempt. The case studies also show that the patches needed to prevent the different faults are simple and the overhead induced by the system during the normal run of the application is less than 10 %, on average. In a nutshell, this dissertation shows how dynamic slices can be used in fault
location for multithreaded programs and addresses the challenges of scaling it for large executions. Also, it proposes techniques which let applications survive faults, caused due to the execution environment.
</div>
</body>
</html>