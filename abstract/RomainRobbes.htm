<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body>
<div align="justify">
Software changes. Any long-lived software system has maintenance costs
dominating its initial development costs as it is adapted to new or
changing requirements. Systems on which such continuous changes are
performed inevitably decay, making each maintenance task harder. This
problem is not new: The software evolution research community has been
tackling it for more than two decades. However, most approaches have
been targeting individual tasks using an ad-hoc model of software
evolution.
<p>
Instead of only addressing individual maintenance tasks, we propose to
take a step back and address the software evolution problem at its
root by treating change as a first-class entity. We apply the strategy
of reification, used with success in other branches of software
engineering, to the changes software systems experience. Our thesis is
that a reified change-based representation of software enables better
evolution support for both reverse and forward engineering
activities. To this aim, we present our approach, Change-based
Software Evolution, in which first-class changes to programs are
recorded as they happen.
<p>
We implemented our approach to record the evolution of several
systems. We validated our thesis by providing support for several
maintenance task. We found that: Change-based Software Evolution eases
the reverse engineering and program comprehension of systems by
providing access to historical information that is lost by other
approaches. The fine-grained change information we record, when
summarized in evolutionary measurements, also gives more accurate
insights about a system s evolution.  Change-based Software Evolution
facilitates the evolution of systems by integrating program
transformations, their definition, comprehension and possible
evolution in the overall evolution of the system. Further, our
approach is a source of fine-grained data useful to both evaluate and
improve the performance of recommender systems that guide developers
as they change a software system.
<p>
These results support our view that software evolution is a continuous
process, alternating forward and reverse engineering activities that
requires the support of a model of software evolution integrating
these activities in a harmonious whole.



</div>
</body>
</html>