<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body>
<div align="justify">
Research on program comprehension (PC) is very important, because the amount of source code in mission-critical applications is increasing world-wide.  Software maintenance takes more than one half of all software development time and the effort to understand code about a half of this.   Although of great importance, research on program comprehension is not yet very advanced.
<p>
Notwithstanding with its many excellent qualities, modern object-oriented code is harder to understand and more difficult to analyze than former procedural languages due to encapsulation and object bindings. As a solution for this problem we propose an information flow structure with four stages to help us in systematically obtaining new knowledge from the code. The first stage consists of loading the program through GrammarWare into a symbolic form to function as a construction for the model, as the second stage, which we call here ModelWare.
<p>
In our research we wanted to find the smallest possible structure that could be used for modeling. This gave us the idea of an "atom" in the source code. The idea was then implemented as a so-called hybrid object, combining, in an ideal manner, object based abstraction and expressiveness of a logic language. As a consequence, semantics and associations could be presented in a symbolic form.
The third stage, code simulation based on SimulationWare enables symbolic analysis, which brings to light a program simulation functionality that is comparable with dynamic analysis. The last stage in our methodology, KnowledgeWare, is aimed for collecting knowledge: the user constructs, stage by stage, the most suitable representations for the current tasks, which include code inspection, error detection and verification of current operations.
<p>
The methodology is programmed with Visual Prolog and implemented in our JavaMaster tool, which enables the handling of Java code in accordance with the main stages. The formalism of the resulting implementation architecture combines the main functions in program development: reverse engineering for maintenance, and forward engineering for design of new code.
</div>
</body>
</html>