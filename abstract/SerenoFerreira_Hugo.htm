<p>The field of Software Engineering (SE) could be regarded as in crisis since the early days of its birth. Project overruns and failures have hitherto characterized the norm, blamed upon the unreasonable expectations set by the stakeholders and the constant change of the requirements. While some development processes struggle to systematically eradicate these barriers from software development, other methodologies, specially those coined agile, promote a continuous embrace of change as a first-class property of this activity. Even so, it is a yet to be disputed contingency that there is no silver bullet; no single, unifying methodology capable of consistently improving the efficiency of software development by even an order of magnitude.</p>

<p>Nonetheless, the agglomeration of empirical evidence is now starting to suggest that <i>change</i>, more than a mere cause, may be a symptom of a deeper nature, directly related to inherent properties of some of the domains software tries to address -- software may need to be under constant change because any modeling of those domains is incomplete since the day it starts.</p>

<p>Therefore, if such solutions need to be constantly evolving and adapted to new realities, hence regarded as incomplete by design, shouldn't they be actively designed for incompleteness? If agile methodologies shifted the way teams and individuals plan development to embrace change, how should one deliberately design to cope with continuous change?</p>

<p>Even if the answer to this question could be promptly given, the goal of pragmatically contributing to the body of knowledge in the SE field rises a problem of its own. As knowledge grows in a specific area, solutions are captured and documented by experts in books, research papers, concrete implementations, webpages, etc. While one may intuitively think that this growth implies better design, it has been shown that the way (and the amount) this knowledge is captured raises an important issue per-se. Design, as an intentional act of choice, is constantly overwhelmed by the sheer quantity of available information.</p>

<p>In this dissertation, the author starts by presenting arguments pointing to how these incomplete by design systems are a common issue in nowadays practice of software engineering. During that overview, one must inevitably delve into the forces that lead architects, designers and developers to recognize these kind of systems. The target thus become readers who have recognized (or are interested) in the set of systems that show a high degree of variability and incompleteness, and which goal is to reduce the overall effort -- monetary cost, available time and resources, required skills, resulting complexity, etc. -- of coping with continuous change made to the domain model. Mainly, this dissertation aims to answer what form should this type of systems take, and which kind of tools and infrastructures should be available to support the development of such software?</p>

<p>The way this problem is here coped, with a permanent focus on the development of prescriptive contributions to the SE body of knowledge, is as follows. First, it is presented as a formalization of a unified conceptual pattern language, following the theories first laid by Alexander et al., for systems which domain model is target of continuous change during runtime. The underlying meta-architecture of these systems is known as Adaptive Object-models, and this pattern language aims to answers questions such as when do these type of systems occur, their advantages and disadvantages, their underlying requirements, the set of available techniques and solutions and their main benefits and liabilities.</p>

<p>The author then proceeds to specify a reference architecture of an object-oriented framework capable of dealing with such systems. Questions here addressed include the type and form of needed infrastructures, what abstractions should be made and supported, the generic functionalities it should provide, its default behavior and points of extension. The author takes a further step in providing and detailing an industrial-level implementation of such framework, along with the specific design issues that arise only when pursuing such concrete artifacts.</p>

<p>Finally, the author's main thesis is validated by providing empirical evidence of the framework benefits through industrial use-case applications and controlled academic quasi-experiments. Two commercial software systems built on top of that framework are used as case studies, reflecting their own specific context, their requirements, their particular problems, and the way the framework -- and the underlying theories here built -- were used to address them, the outcomes, and the lessons learned. Inherent threats to this type of validation are further dismissed by presenting the results of a (quasi-)experiment within a controlled academic environment, where the results of studying groups of undergraduate students following different treatments are shown to be consistent with those earlier presented.</p>
