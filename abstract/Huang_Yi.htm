<p>Today, most new software products use concurrency in some capacity. However, the expressive power afforded by the use of concurrency comes at the expense of increased complexity. Without proper synchronization, concurrent access to shared objects can lead to race conditions, and incorrect synchronization logic can lead to starvation or deadlock. Moreover, concurrency confounds the development of reusable software modules because code implementing an application's synchronization logic tends to be tightly interleaved with the  functional  code. Interleaving complicates program understanding and maintenance, producing brittle applications.</p> 
 
<p>Contract-based models of synchronization, such as the Synchronization Units Model (Szumo), attempt to address these problems by: (1) expressing synchronization concerns in declarative synchronization contracts to separate them from functional code; and (2) using a runtime system that dynamically interprets and  negotiates  the contracts, thereby automatically synchronizing threads. However, this approach requires a special compiler and runtime system, making it difficult to integrate Szumo into mainstream object-oriented programming languages or conduct empirical studies to understand software engineering tradeoffs when using Szumo or hand coding synchronization.</p>
 
<p>This thesis investigates two  lighter-weight  approaches for integrating a contract-based synchronization model with a mainstream object-oriented programming language. The first approach works with any multi-threaded Java program. In this approach, an application programmer adds special Java annotations to a class whose methods contain only functional code. A compiler plugin generates synchronization code from the annotated program based on synchronization concerns declared in the annotations; the generated synchronization code is added to the annotated program, which then executes in a standard JVM. The second approach targets IP telecommunication (IPT) services that are deployed to a SIP servlets container. It makes use of a synchronization middleware. Instead of embedding synchronization code in the message handlers that implement a service, a programmer provides a synchronization contract that is loaded when the service is deployed to a container running our middleware. The middleware intercepts messages that a container routes to the service and consults the contract to determine when to schedule the message handler thread.</p> 
 
<p>Contributions of work reported in this thesis include:</p>
<ul>
<li>Development of a generative approach that permits use of synchronization annotations with a mainstream object-oriented language.</li>
<li>Development of a middleware approach that permits use of contract-based synchro- nization with a standard execution platform for services.</li> 
<li>Demonstration that contract-based synchronization enables packaging the implementation of synchronization as an OTS component, which can be seamlessly swapped with one that implements a different protocol, e.g., to tune performance. </li>
<li>Presentation of results of case studies with both approaches. </li>
</ul>
<p>The work described in this thesis was performed in collaboration with AT&amp;T Research Labs and Oracle Research Labs.</p>
